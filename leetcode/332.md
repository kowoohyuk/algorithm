# leetcode

## Reconstruct Itinerary

## 파이썬 알고리즘 인터뷰

### 풀이

먼저 어휘순 방문이라는 문제의 조건을 맞추기 위해 **tickets** 를 정렬한다.  
그리고 중복된 지점의 정보를 저장하기 위해 **obj** 객체 안에 정렬된 tickets의 요소들을 더 한다.  

```javascript
const obj = {};
tickets.sort().forEach(v => {
  if(obj[v[0]]) {
    obj[v[0]].push(v[1]);
  } else {
    obj[v[0]] = [v[1]];
  }
});
/*
tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
obj = {
  'ATL' : ['JFK', 'SFO'],
  'JFK' : ['ATL', 'SFO'],
  'SFO' : ['ATL']
}
*/
```

이후 정렬된 값들을 dfs를 통해 순차적으로 방문하며, 결과 값을 담는 배열 **result** 에 더 한다.  

```javascript
const result = [];
const dfs = start => {
  while(obj[start] && obj[start].length > 0) {
    dfs(obj[start].shift());
  }
  result.push(start);
}
dfs('JFK');
/*
  방문한 순서대로 push가 되므로 결과 값을 반환할 때는 reverse()한다.
*/
return result.reverse();
```

**코드**

```javascript
const findItinerary = function(tickets) {
  const obj = {};
  const result = [];
  tickets.sort().forEach(v => {
    if(obj[v[0]]) {
      obj[v[0]].push(v[1]);
    } else {
      obj[v[0]] = [v[1]];
    }
  });
  const dfs = start => {
    while(obj[start] && obj[start].length > 0) {
      dfs(obj[start].shift());
    }
    result.push(start);
  }
  dfs('JFK');
  return result.reverse();
};
```

### 아쉬운 점

정렬하는 부분에서 책의 풀이를 참고한 점이 아쉽다..
