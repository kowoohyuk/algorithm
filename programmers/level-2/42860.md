# 프로그래머스

## 조이스틱

### 풀이

**조이스틱의 상하 이동**
1. 문자열 **name**의 i번 째 **문자(c)**를 꺼낸다.
2. **c**가 'A'인지 확인한다.
    - 'A'가 아니라면 그 문자를 바꾸는데 필요한 조이스틱의 상하이동을 계산한다.
3. i가 name의 길이와 같아질 때까지 반복한다.

**조이스틱의 좌우 이동**
1. 문자열 **name**의 i번 째 **문자(c)**를 꺼낸다.
2. **c**가 'A'인지 확인한다.
    - 'A'가 아니라면 i를 1증가시키며, 1번으로 돌아간다.
3. i를 **j**에 할당한다.
4. 'A'가 아닌 값을 발견할 때 까지 **j**를 증가시킨다.
5. 최솟값이 저장된 변수 **min**과 j까지 역순으로 방문했을 때의 길이값을 비교하여 작은 값을 **min**에 할당한다.
6. i가 name의 길이와 같아질 때까지 반복한다.

**결과**
상하 이동 + 좌우 이동

상하 이동은 해당 문자가 A 또는 Z와 가까운지에 따라 쉽게 식을 세울 수 있다.  
핵심적인 부분은 좌우 이동이다.  
직진보다 거꾸로 가는게 더 짧을 수 있음을 주의해야 했다.  
곰곰히 정리해보니 다음과 같은 조건을 도출할 수 있었다.  

> 1. 모든 경우에서 좌우 이동 최적의 값은 **문자열의 길이 - 1** 이하일 수 밖에 없다.

당연하게도 조이스틱을 가장 적게 움직이는 값이 문자열의 길이 - 1보다 커질 수가 없다.  
직진하는 것 보다 돌아가는 값이 크다면 그 값은 적게 움직이는 값이 아니기 때문이다.  

그렇다면 역순으로 가는게 이득인 경우는 어떻게 구할 수 있을까?  
케이스를 통해 생각해봤다.

```javascript
name = 'JSOAAAAAAN';
최소 좌우 이동 횟수 = 4(JNSO순)
J에서 S로 이동,
S에서 O로 이동은 정방향이 1, 역방향이 9로 정방향이 낮은 값이다.
그리고 O에서 N으로의 이동은 역방향이 3으로 정방향 7보다 낮은 값이다.
하지만 O까지 도달한 이후 N으로 역방향 이동을 하게 되면 결과인 4가 아닌 5가 나오게 된다.

'A'가 아닌 값에서 'A'가 아닌 값으로의 이동에서는 마땅한 식이 생각나지 않는다.
그렇다면 'A'인 값에서 'A'가 아닌 값으로의 이동은 어떨까?
A[3]에서 N은 정방향 6, 역방향 4가 된다.

답과 비슷한 값을 찾았다.

다른 값으로 비교해보자.
        0    5   10  
name = 'CADAEAAFAA';
최소 좌우 이동 횟수 = 7(CDEF순)
A[1]에서 D로 가는 경우 정방향 1, 역방향 9
A[3]에서 E로 가는 경우 정방향 1, 역방향 9
A[5]에서 F로 가는 경우 정방향 2, 역방향 8
A[6]에서 F로 가는 경우 정방향 1, 역방향 9
8??? 9???
???
```

딱히 답이 생각나지 않았다.  
그래서 간단하게 좌, 우 방향만 고려해서 다시 접근을 해보았더니 답이 나왔다.  

I가 0, J가 문자열의 길이라고 하자.  
A에서 B라는 두 개의 지점이 있을 때, 최적의 값은 I로 부터 A까지의 거리와 J로 부터 B까지의 거리 중 짧은 곳이 된다.  
I => A가 더 짧다고 했을 때는 I에서 A로 갔다가 돌아온 뒤, J에서 B로 가게 되면 수정이 필요한 모든 곳을 방문하게 된다.  
반대로 J => B가 더 짧다고 했을 때는 J에서 B로 갔다가 돌아온 뒤, I에서 A로 가면 된다.  

```javascript
name = 'JSOAAAAAAN';
좌측에서 O까지의 거리는 2, 우측에서 N까지의 거리는 0으로 보이지만
0번째 지점에서 N으로 가기 위해서는 좌측으로 조이스틱을 움직여야 하므로
left = 2, right = 1이 된다.
right가 더 작은 값이므로 right에 방문했다가 left를 방문했을 때의 값은 아래와 같다.
인덱스 0에서 역방향으로 N으로 갔다가 돌아오는 값은 2
인덱스 0에서 다시 O로 가는 값은 2

다른 값으로 비교해보자.
        0    5   10  
name = 'CADAEAAFAA';
좌측에서 E까지의 거리는 4, 우측에서 F까지의 거리는 3
인덱스 0에서 역방향으로 F까지 갔다가 돌아오는 값은 6
이후 E로 가는 값은 4

마지막 값과 이전 값의 비교로는 찾을 수가 없다.
그렇다면 반복해서 찾으면 어떨까?

1. C, D
left = 0, right = 8, answer = 8
2. D, E
left = 2, right = 6, answer = 10
3. E, F
left = 4, right = 3, answer = 10

```

마찬가지로 답인 7을 찾을 수 없다.  
왜냐하면 주어진 F까지 정방향으로만 이동하면 끝나기 때문인데  
이를 위해서는 F가 마지막 문자가 아닐 때를 고려하는 반복문이 필요하다.

구상한 코드는 아래와 같다.

```javascript
let min = arr.length - 1; // 최초의 min은 정방향으로 모든 글자를 방문하는 값.
let i = 0;
while(i < arr.length) {
  if(arr[i] === 'A') { // 인덱스에 해당하는 값이 'A'라면 이전 값은 무조건 'A'가 아니다.
    let j = i;
    while(j < arr.length && arr[j] ==='A') { // A가 아닌 값을 찾을 때 까지 j를 증가시킨다.
      j++;
    }
    const left = i - 1; // i는 'A'의 인덱스이므로 이전 인덱스를 지정한다.
    const right = arr.length - j;
    min = Math.min(min, left * 2 + right, right * 2 + left);
    i = j; // 인덱스 j에는 인덱스 i - 1 다음의 'A'가 아닌 값이 들어있으므로 i값에 j를 할당한다.
    // 만약 i = j가 없다면 JAAAAJ가 있을 때, 인덱스 1의 A에 방문한 이후, 인덱스 2의 A도 바깥의 조건문을 통과하게 된다.
  }
  i++;
}
```

**코드**

```javascript
function solution(name) {
  const arr = name.split('');
  let answer = arr.reduce((acc , v) => {
    let code = v.charCodeAt() - 65;
    if (code > 13) code = 26 - code;
    return acc + code;
  }, 0);
  let min = arr.length - 1;
  let i = 0;
  while(i < arr.length) {
    if(arr[i] === 'A') {
      let j = i;
      while(j < arr.length && arr[j] ==='A') {
        j++;
      }
      const left = i - 1;
      const right = arr.length - j;
      min = Math.min(min, left * 2 + right, right * 2 + left);
      i = j;
    }
    i++;
  }
  return answer + min;
}
```

### 아쉬운 점

이전에는 이렇게 어렵게 풀었던 문제가 아닌걸로 기억한다.  
한 번에 해답에 접근하지 못한 점이 아쉽다..
