# 프로그래머스

## 위장

> 같은 종류의 의상을 착용할 수 없다는 점을 유의하자.

### 잘못된 풀이

1. **clothes**의 요소들을 종류를 기준으로 분류하여 집계한 객체 또는 배열을 생성한다.
2. 집계한 객체의 모든 요소 값을 곱한 값에서 clothes의 값을 더한 값이 정답이 된다.

```javascript
const clothes = [['선글라스', '머리'], ['파란 선글라스', '머리'], ['반바지', '다리']]
const obj = {
  '머리': 2,
  '다리': 1
}
return obj.머리 * obj.다리 + clothes.length; // 5
/*
  경우의 수
  1. 선글라스
  2. 파란 선글라스
  3. 반바지
  4. 선글라스 + 반바지
  5. 파란 선글라스 + 반바지
*/
```

에러가 발생했고, 위의 풀이는 종류가 두 가지일 경우에만 성립한다는 사실을 깨달았다.    
만약 옷이 3종류라고 했을 때, 경우의 수는 아래와 같다.  

> [1, 4, 2]
> 생각한 풀이대로 계산
> 1 * 4 * 2 + 7 = 15
> 실제 경우의 수
> 1 * 4 = 4
> 1 * 2 = 2
> 4 * 2 = 8
> 1 * 4 * 2 = 8
> 1
> 4
> 2
> 4 + 2 + 8 + 8 + 1 + 4 + 2 = 29

### 옳은 풀이

1. **clothes**의 요소들을 종류를 기준으로 분류하여 집계한 객체 또는 배열을 생성한다.
2. 집계한 객체의 모든 요소 값을 각각 1씩 더한 뒤 곱한 값에서 1을 감소시킨 값이 정답이 된다.

> [1, 4, 2]
> 2 * 5 * 3 - 1 = 29

왜 이런 결과가 나올까?  
이는 모든 종류의 옷을 입어야 하는게 아닌 해당 종류의 옷을 입지 않는 경우도 포함해야 하기 때문이다.  
기존의 풀이에서는 옷이 3종류가 되면 3종류를 모두 착용한 경우의 수에 한 종류만 착용한 경우의 수만 계산한다.  
하지만 실제로는 3종류의 옷이 주어졌을 때, 두 가지의 옷만 입는 경우도 고려해야 한다.  

```javascript
const clothes = [['선글라스', '머리'], ['파란 선글라스', '머리'], ['반바지', '다리'], ['바람막이', '겉옷']]
const obj = {
  '머리': 2,
  '다리': 1,
  '겉옷': 1,
}
/*
  경우의 수
  한 종류
  1. 선글라스
  2. 파란 선글라스
  3. 반바지 
  4. 바람막이

  두 종류
  1. 선글라스 + 반바지
  2. 선글라스 + 바람막이
  3. 파란 선글라스 + 반바지
  4. 파란 선글라스 + 바람막이
  5. 반바지 + 바람막이

  세 종류
  1. 선글라스 + 반바지 + 바람막이
  2. 파란 선글라스 + 반바지 + 바람막이
*/
```

왜 **집계한 객체의 모든 요소 값을 각각 1씩 더한 뒤 곱한 값에서 1을 감소시킨 값**일까?  
위에서 말했듯 3종류의 옷이 있을 때, 2종류의 옷을 입는 경우의 수를 구한다는 것은 해당 종류의 옷을 안입는 경우의 수를 구해야한다는 뜻이다.  
결국 그 옷을 입는 경우의 수에서 1을 더 한 값을 곱하게 된다.

> answer *= (v + 1)

그리고 마지막에 1을 감소시키게 된다.  
이는 문제의 조건에서 적어도 1종류의 옷은 무조건 입는 상황이 존재하는데  
위의 식대로 모든 종류의 경우의 수를 곱하는 과정에서 안 입는 경우를 고려하게 되면  
모든 옷을 입지 않는 상황이 나오기 때문에 해당 경우의 수를 제외하기 위함이다.

**코드**

```javascript
function solution(clothes) {
  const answer = Object.values(clothes.reduce((acc, v) => typeCount(acc, v[1]), {}));
  return answer.reduce((acc, v) => acc * (v + 1), 1) - 1;
}

function typeCount(obj, v) {
  if(!obj[v]) obj[v] = 0;
  obj[v] += 1;
  return obj;
}
```

### 아쉬운 점

경우의 수를 제출하고 나서 왜 안되나 했더니 이번에도 문제를 제대로 읽지 않아서 발생한 문제였다..
